<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Multiplayer Tetris (Local)</title>
<style>
  :root{
    --bg:#071223; --panel:#0b1a2a; --muted:#cfe9ff; --accent:#4cc0ff;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,var(--bg),#041423);color:var(--muted);font-family:Inter,system-ui,Arial;display:flex;flex-direction:column;min-height:100vh}
  header{padding:12px 16px;display:flex;align-items:center;gap:12px}
  h1{margin:0;font-size:18px;color:var(--accent)}
  main{flex:1;display:flex;gap:12px;padding:12px;align-items:flex-start;justify-content:center;flex-wrap:wrap}
  .player{
    background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);width:320px;display:flex;flex-direction:column;align-items:center;
  }
  .board { background:#000;border-radius:6px; }
  canvas{display:block; width:240px; height:400px; image-rendering:pixelated; background:linear-gradient(180deg,#081827,#071323); border-radius:6px }
  .info{width:100%;display:flex;justify-content:space-between;align-items:center;margin-top:8px}
  .score{font-weight:700;color:var(--accent)}
  .controls{display:flex;gap:6px;margin-top:10px;flex-wrap:wrap;justify-content:center}
  .btn{padding:8px 12px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);color:var(--muted);font-weight:600}
  .touch-row{display:flex;gap:6px}
  .leaderboard{
    width:320px;background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);
    max-height:480px;overflow:auto;
  }
  .lb-title{font-weight:800;margin-bottom:8px;color:var(--accent)}
  ul{padding-left:18px;margin:0}
  li{margin-bottom:6px}
  footer{padding:8px 12px;text-align:center;color:rgba(255,255,255,0.45);font-size:13px}
  @media(max-width:900px){
    main{flex-direction:column;align-items:center}
    .player, .leaderboard{width:92%}
    canvas{width:92%;height:60vh;max-height:520px}
  }
</style>
</head>
<body>
  <header>
    <h1>Multiplayer Tetris — Local</h1>
    <div style="margin-left:auto;font-size:13px;color:rgba(255,255,255,0.65)">Shared highs stored in browser</div>
  </header>

  <main>
    <!-- Player 1 -->
    <div class="player" id="player1">
      <div style="font-size:14px;font-weight:800">Player 1 (Arrows)</div>
      <canvas id="c1" width="240" height="400" class="board"></canvas>
      <div class="info"><div>Score</div><div id="s1" class="score">0</div></div>
      <div class="info" style="margin-top:6px"><div>Lines</div><div id="l1">0</div></div>

      <div class="controls" style="margin-top:8px">
        <div class="touch-row">
          <button class="btn" data-p="1" data-act="left">←</button>
          <button class="btn" data-p="1" data-act="rotate">⟳</button>
          <button class="btn" data-p="1" data-act="right">→</button>
          <button class="btn" data-p="1" data-act="down">↓</button>
        </div>
        <div class="touch-row" style="margin-top:6px">
          <button class="btn" data-p="1" data-act="drop">HARD DROP</button>
        </div>
      </div>
    </div>

    <!-- Player 2 -->
    <div class="player" id="player2">
      <div style="font-size:14px;font-weight:800">Player 2 (A D W S F)</div>
      <canvas id="c2" width="240" height="400" class="board"></canvas>
      <div class="info"><div>Score</div><div id="s2" class="score">0</div></div>
      <div class="info" style="margin-top:6px"><div>Lines</div><div id="l2">0</div></div>

      <div class="controls" style="margin-top:8px">
        <div class="touch-row">
          <button class="btn" data-p="2" data-act="left">←</button>
          <button class="btn" data-p="2" data-act="rotate">⟳</button>
          <button class="btn" data-p="2" data-act="right">→</button>
          <button class="btn" data-p="2" data-act="down">↓</button>
        </div>
        <div class="touch-row" style="margin-top:6px">
          <button class="btn" data-p="2" data-act="drop">HARD DROP</button>
        </div>
      </div>
    </div>

    <!-- Leaderboard -->
    <div class="leaderboard" id="leaderboard">
      <div class="lb-title">Top Scores (Local)</div>
      <ol id="lbList"></ol>
      <div style="margin-top:10px;display:flex;gap:8px">
        <button class="btn" id="clearScores">Clear Scores</button>
        <button class="btn" id="newGames" style="margin-left:auto">New Games</button>
      </div>
    </div>
  </main>

  <footer>Keyboard: Player1 = Arrow keys / Player2 = A (left), D (right), W (rotate), S (down), F (hard drop)</footer>

<script>
(() => {
  // ---- Shared utilities & constants ----
  const COLS = 10, ROWS = 20, BLOCK = 12; // block size for drawing (we scale canvas with CSS)
  const TETROMINOS = {
    I: { matrix:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], color:'#4cc0ff' },
    J: { matrix:[[1,0,0],[1,1,1],[0,0,0]], color:'#7efc6a' },
    L: { matrix:[[0,0,1],[1,1,1],[0,0,0]], color:'#ffd166' },
    O: { matrix:[[1,1],[1,1]], color:'#ff6b6b' },
    S: { matrix:[[0,1,1],[1,1,0],[0,0,0]], color:'#9b8cff' },
    T: { matrix:[[0,1,0],[1,1,1],[0,0,0]], color:'#ff9f80' },
    Z: { matrix:[[1,1,0],[0,1,1],[0,0,0]], color:'#ffd38f' }
  };
  function randKey(){ const ks=Object.keys(TETROMINOS); return ks[Math.floor(Math.random()*ks.length)]; }

  // ---- Highscore storage (shared) ----
  const HS_KEY = 'tetris_local_highscores_v1';
  function loadHighscores(){ try { return JSON.parse(localStorage.getItem(HS_KEY) || '[]'); } catch(e){ return []; } }
  function saveHighscores(list){ localStorage.setItem(HS_KEY, JSON.stringify(list)); }
  function addScore(name, score){
    const list = loadHighscores();
    list.push({ name: name || 'Anon', score: Math.floor(score), when: Date.now() });
    list.sort((a,b)=>b.score - a.score);
    saveHighscores(list.slice(0, 10));
    renderLeaderboard();
  }
  function clearScores(){ saveHighscores([]); renderLeaderboard(); }

  // ---- Leaderboard rendering ----
  const lbList = document.getElementById('lbList');
  function renderLeaderboard(){
    const items = loadHighscores();
    lbList.innerHTML = '';
    if (items.length === 0){ lbList.innerHTML = '<li style="color:rgba(255,255,255,0.5)">No scores yet</li>'; return; }
    items.forEach(it => {
      const d = new Date(it.when);
      const li = document.createElement('li');
      li.textContent = `${it.name} — ${it.score} (${d.toLocaleDateString()})`;
      lbList.appendChild(li);
    });
  }

  // ---- Player class (each player has its own board & loop) ----
  class Player {
    constructor(canvasId, displayScoreId, displayLinesId){
      this.canvas = document.getElementById(canvasId);
      this.ctx = this.canvas.getContext('2d');
      // use canvas size in px; drawing scaled by cell size BLOCK
      this.canvas.width = COLS * BLOCK;
      this.canvas.height = ROWS * BLOCK;
      this.scoreEl = document.getElementById(displayScoreId);
      this.linesEl = document.getElementById(displayLinesId);

      this.board = this.createMatrix(COLS, ROWS);
      this.piece = null;
      this.next = null;
      this.dropCounter = 0;
      this.dropInterval = 1000; // ms
      this.lastTime = 0;
      this.running = true;
      this.paused = false;
      this.score = 0;
      this.lines = 0;
      this.level = 1;

      // start
      this.next = this.randomPiece();
      this.spawnPiece();
      this.update(0);
    }

    createMatrix(w,h){ const m=[]; for(let i=0;i<h;i++) m.push(new Array(w).fill(0)); return m; }

    randomPiece(){ const k = randKey(); const m = JSON.parse(JSON.stringify(TETROMINOS[k].matrix)); return { type:k, matrix:m, color:TETROMINOS[k].color, x:0, y:0 }; }

    rotateMatrix(m, dir){
      for(let y=0;y<m.length;y++) for(let x=0;x<y;x++) [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
      if (dir>0) m.forEach(row => row.reverse()); else m.reverse();
    }

    collide(matrix, piece){
      const m = piece.matrix;
      for(let y=0;y<m.length;y++){
        for(let x=0;x<m[y].length;x++){
          if (m[y][x]){
            const bx = piece.x + x, by = piece.y + y;
            if (by < 0) continue;
            if (bx < 0 || bx >= COLS || by >= ROWS) return true;
            if (matrix[by][bx]) return true;
          }
        }
      }
      return false;
    }

    mergePiece(){
      const m = this.piece.matrix;
      for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++) if (m[y][x]){
        const bx = this.piece.x + x, by = this.piece.y + y;
        if (by >= 0 && by < ROWS && bx >=0 && bx < COLS) this.board[by][bx] = this.piece.color;
      }
    }

    clearLines(){
      let cleared = 0;
      outer: for(let y=ROWS-1;y>=0;y--){
        for(let x=0;x<COLS;x++) if (!this.board[y][x]) continue outer;
        // line full
        const row = this.board.splice(y,1)[0].fill(0);
        this.board.unshift(new Array(COLS).fill(0));
        cleared++;
        y++;
      }
      if (cleared){
        this.lines += cleared;
        const points = (cleared === 1 ? 40 : cleared === 2 ? 100 : cleared === 3 ? 300 : 1200) * this.level;
        this.score += points;
        this.level = Math.floor(this.lines / 10) + 1;
        this.dropInterval = Math.max(120, 1000 - (this.level - 1) * 80);
        this.updateUI();
      }
    }

    spawnPiece(){
      this.piece = this.next || this.randomPiece();
      this.next = this.randomPiece();
      this.piece.x = Math.floor((COLS - this.piece.matrix[0].length) / 2);
      this.piece.y = -1;
      if (this.collide(this.board, this.piece)){
        // GAME OVER
        this.running = false;
        this.drawGameOverFlash();
        setTimeout(() => this.onGameOver(), 700);
      }
    }

    hardDrop(){
      while(!this.collide(this.board, { ...this.piece, y: this.piece.y + 1 })) {
        this.piece.y++;
      }
      this.lockPiece();
    }

    softDrop(){
      this.piece.y++;
      if (this.collide(this.board, this.piece)){
        this.piece.y--;
        this.lockPiece();
      }
      this.dropCounter = 0;
      this.updateUI();
    }

    move(dx){
      this.piece.x += dx;
      if (this.collide(this.board, this.piece)) this.piece.x -= dx;
    }

    rotate(dir){
      const old = JSON.parse(JSON.stringify(this.piece));
      this.rotateMatrix(this.piece.matrix, dir);
      // simple wall kick
      let offset = 1;
      while (this.collide(this.board, this.piece)) {
        this.piece.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (Math.abs(offset) > this.piece.matrix[0].length) { this.piece = old; return; }
      }
    }

    lockPiece(){
      this.mergePiece();
      this.clearLines();
      this.spawnPiece();
    }

    draw(){
      const ctx = this.ctx;
      ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
      // background
      ctx.fillStyle = '#071827';
      ctx.fillRect(0,0,this.canvas.width,this.canvas.height);

      // draw board cells
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          if (this.board[y][x]){
            this.drawCell(x,y,this.board[y][x]);
          } else {
            // subtle grid background for empty cells
            ctx.fillStyle = 'rgba(255,255,255,0.01)';
            ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);
          }
        }
      }
      // draw current piece
      const m = this.piece.matrix;
      for (let y=0;y<m.length;y++){
        for (let x=0;x<m[y].length;x++){
          if (m[y][x]){
            const bx = this.piece.x + x, by = this.piece.y + y;
            if (by >= 0) this.drawCell(bx, by, this.piece.color);
          }
        }
      }
    }

    drawCell(x,y,color){
      const ctx = this.ctx;
      ctx.fillStyle = color;
      ctx.fillRect(x*BLOCK + 1, y*BLOCK + 1, BLOCK - 2, BLOCK - 2);
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.strokeRect(x*BLOCK + 1, y*BLOCK + 1, BLOCK - 2, BLOCK - 2);
    }

    drawGameOverFlash(){
      const ctx = this.ctx;
      ctx.fillStyle = 'rgba(255,0,0,0.4)';
      ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
    }

    updateUI(){
      if (this.scoreEl) this.scoreEl.textContent = this.score;
      if (this.linesEl) this.linesEl.textContent = this.lines;
    }

    onGameOver(){
      // prompt for name and save highscore
      const name = prompt('Game Over! Enter your name for the leaderboard:', 'Player');
      addScore(name || 'Player', this.score);
      // allow restart
      this.resetGame();
    }

    resetGame(){
      this.board = this.createMatrix(COLS, ROWS);
      this.piece = null;
      this.next = this.randomPiece();
      this.score = 0; this.lines = 0; this.level = 1; this.dropInterval = 1000;
      this.running = true;
      this.updateUI();
      this.spawnPiece();
    }

    update(time = 0){
      if (!this.running) return;
      if (this.paused){ this.lastTime = time; requestAnimationFrame(t => this.update(t)); return; }
      const delta = time - this.lastTime;
      this.lastTime = time;
      this.dropCounter += delta;
      if (this.dropCounter > this.dropInterval){
        this.softDrop();
        this.dropCounter = 0;
      }
      this.draw();
      this.updateUI();
      requestAnimationFrame(t => this.update(t));
    }
  }

  // ---- Create two players ----
  const P1 = new Player('c1', 's1', 'l1');
  const P2 = new Player('c2', 's2', 'l2');
  renderLeaderboard();

  // ---- Controls (keyboard) ----
  window.addEventListener('keydown', (e) => {
    // Player1: arrow keys
    if (e.key === 'ArrowLeft') P1.move(-1);
    else if (e.key === 'ArrowRight') P1.move(1);
    else if (e.key === 'ArrowDown') P1.softDrop();
    else if (e.key === 'ArrowUp') P1.rotate(1);
    else if (e.key === ' ') { e.preventDefault(); P1.hardDrop(); }

    // Player2: A D W S F
    const k = e.key.toLowerCase();
    if (k === 'a') P2.move(-1);
    else if (k === 'd') P2.move(1);
    else if (k === 's') P2.softDrop();
    else if (k === 'w') P2.rotate(1);
    else if (k === 'f') P2.hardDrop();
  });

  // ---- Touch buttons ----
  document.querySelectorAll('.btn').forEach(btn => {
    btn.addEventListener('click', (ev) => {
      const p = ev.currentTarget.getAttribute('data-p');
      const act = ev.currentTarget.getAttribute('data-act');
      const player = (p === '1') ? P1 : P2;
      if (!player.running) return;
      if (act === 'left') player.move(-1);
      else if (act === 'right') player.move(1);
      else if (act === 'down') player.softDrop();
      else if (act === 'rotate') player.rotate(1);
      else if (act === 'drop') player.hardDrop();
    });
  });

  // ---- Leaderboard & buttons ----
  document.getElementById('clearScores').addEventListener('click', ()=> { if (confirm('Clear all local scores?')) clearScores(); });
  document.getElementById('newGames').addEventListener('click', ()=> { P1.resetGame(); P2.resetGame(); });

  // initial render
  renderLeaderboard();
})();
</script>
</body>
</html>
